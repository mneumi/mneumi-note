## 初识枚举

### 枚举概述

Java中**枚举**是一种**特殊的类**

### 枚举作用

枚举一般表示一组常量：比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等



## 定义枚举

### 基础定义

使用 `enum` 关键字定义枚举，每个常量之间用逗号`,`分隔，末尾加分号`;`结束

命名规则：使用全大写，用下划线分隔

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}
```

### 内部定义枚举

像内部类一样

```java
public class Main
{
    enum Season {
        SPRING,
        SUMMER,
        AUTUMN,
        WINTER;
    }
 
    // 执行输出结果
    public static void main(String[] args)
    {
        Season s = Season.WINTER;
        System.out.println(s);
    }
}
```



## 枚举使用

### 基础使用

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {
        Season s = Season.AUTUMN;
        System.out.println(s);
    }
}
```

### 枚举比较

枚举是一种特殊的类，一般的类对象对比需要使用`equals`方法，但是枚举不需要，可以直接使用`==`进行对比

```java
// 下面的写法是可以的，且推荐的
if (s == Season.WINTER) {}

// 下面的写法是可以的，但比较长
if (s.equals(Season.WINTER)) {}
```

### values静态方法

values()：返回枚举类中所有的值组成的数组

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {
        // 调用 values()
        Season[] arr = Season.values();
        
        System.out.println(arr);
    }
}
```

### valueOf静态方法

valueOf()：返回指定字符串值的枚举常量

不存在的会报错 `IllegalArgumentException`

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {        
        System.out.println(Season.valueOf("WINTER"));
        System.out.println(Season.valueOf("NotExists")); // IllegalArgumentException
    }
}
```

### name实例方法

name()：返回常量名

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {
		String sName = Season.WINTER.name(); 
        System.out.println(sName); // "WINTER"
    }
}
```

与`toString`对比

* 默认情况下，对枚举常量调用`toString()`会返回和`name()`一样的字符串
* 但是`toString()`可以被覆写，而`name()`则不行
* 判断枚举常量的名字，要始终使用name()方法，绝不能调用toString()

### ordinal实例方法

ordinal()：找到每个枚举常量的索引，就像数组索引一样

要编写健壮的代码，就不要依靠`ordinal()`的返回值，因为在新增或删除枚举值时，`ordinal`值会改变

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {
        // 调用 values()
        Season[] arr = Season.values();
        
        for (Season s: arr) {
            System.out.println(s.ordinal());
        }
    }
}
```

### switch枚举

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
  public static void main(String[] args) {
    Season s = Season.WINTER;

    switch(s) {
      case SPRING:
        System.out.println("春天");
        break;
      case SUMMER:
         System.out.println("夏天");
        break;
      case AUTUMN:
        System.out.println("秋天");
        break;
      case WINTER:
        System.out.println("冬天");
        break;
      default:
        throw new RuntimeException("cannot process " + s);
    }
  }
}
```

### 迭代枚举

```java
enum Season {
    SPRING,
    SUMMER,
    AUTUMN,
    WINTER;
}

public class Main {
    public static void main(String[] args) {
        for (Season s: Season.values()) {
            System.out.println(s);
        }
    }
}
```



## 枚举与类的联系

### 概述

Java中，枚举是特殊的**类**，所以枚举像类一样，可以拥有**字段**、**方法**、**构造方法**和**抽象方法**等类才具有的性质

### 特点

* 定义的`enum`类型总是继承自`java.lang.Enum`，且**无法被继承**
* 只能定义出`enum`的实例，而**无法通过`new`操作符创建`enum`的实例**
* 定义的每个实例都是引用类型的唯一实例**（所以可以用==判断相等）**

### 构造函数与字段

枚举中的构造方法只能自己调用，即被`private`修饰，构造函数可以在定义枚举时调用

```java
enum Season {
    // 调用构造函数
    SPRING(), SUMMER(), AUTUMN(), WINTER();
    
    // 构造函数只能自己调用，是private的
    private Season() {
        System.out.println("Constructor called for : " + this.toString());
    }
}
```

在枚举中定义的字段必须是`public final`，且必须在构造函数中初始化

```java
enum Season {
    SPRING(100), SUMMER(200), AUTUMN(300), WINTER(400);
    
    public final int seasonCode;
    
    private Season(int codeNumer) {
        this.seasonCode = codeNumber;
    }
}

public class Main {    
    public static void main(String[] args) {
        Season s = Season.WINTER;
        System.out.println(s.seasonCode);
    }
}
```

### 抽象方法

如果枚举中定义了抽象方法，那么需要枚举类中的每个对象都对其进行实现

```java
enum Season {
    // 定义抽象方法
    public abstract String getSeason();
    
    SPRING {
        public String getSeason() { //枚举对象实现抽象方法
            return "春天";
        }
    },
    SUMMER {
        public String getSeason() { //枚举对象实现抽象方法
            return "夏天";
        }
    },
    AUTUMN {
        public String getSeason() { //枚举对象实现抽象方法
            return "秋天";
        }
    },
    WINTER {
        public String getSeason() { //枚举对象实现抽象方法
            return "冬天";
        }
    }
}

public class Main {
    public static void main(String[] args) {
        for (Season s : Season.values()) {
            System.out.print(s.getSeason() + "、");
        }
    }
}
```