## 初识面向对象

### 面向对象是什么

面向对象，Object-Oriented Programming，简称OOP

面向对象是一种编程范式，它以对象的形式对事物进行抽象，把现实世界映射到计算机模型中

### 核心概念

类（class）：可以理解为蓝图或设计稿，任何对象都是由类产生的

对象/实例（instance）：根据类生成的东西，一个类可以生成多个实例，实例可以拥有它的字段和方法

### 面向对象三大特性

封装、继承、多态



## 创建类

### 定义写法

使用`class`关键字

```java
class 类名 {
    // 字段
    // 方法
}
```

### 命名风格

类名以 Pascal 的风格，即每个单词的首字母都大写

### 示例代码

```java
class Student {}
```



## 创建实例

### 创建写法

使用`new`关键字，后跟**构造方法**

### 示例代码

```java
Student st = new Student();
```



## 字段

### 概念

类中可以定义类所拥有的字段，类生成的每个对象的字段都是自己特有的，互不干扰**（static字段除外）**

### 定义写法

类的字段写在类中，形式如

```java
修饰符 类型 字段名;
// 可以设置初始值
修饰符 类型 字段名 = 初始值;
```

### 示例代码

```java
class Student {
    public String name;
    protected int age;
    private double height;
    boolean adult = true;
}
```



## 方法

### 定义写法

```java
修饰符 返回值类型 方法名(参数列表) {
    // 方法具体逻辑
}
```

### 可变参数

可变参数用`类型 ...`定义，可变参数相当于数组类型

```java
class Main {
    private int[] nums;
    
    public void addNums(int ...nums) {
        this.nums = nums;
    }
}
```

```java
Main m = new Main();
m.addNums(1,2,3,4,5)
```

与数组参数对比：**可变参数可以保证无法传入`null`**，因为传入0个参数时，接收到的实际值是一个空数组而不是`null`

### 示例代码

```java
class Student {
    String name;
    int age;
    double height;
    boolean adult = true;
    
    void sayHello() {
        System.out.printf("Hello, I'm %s", name);
    }
    
    public String getName() {
        return this.name;
    }
    
    private int getAge() {
        return this.age;
    }
    
    protected boolean isAdult() {
        return this.adult;
    }
}
```



## this引用

### 概述

方法内部，可以使用一个隐含的变量`this`，它始终指向当前实例（比JavaScript简单很多！）

通过`this.field`可以访问当前实例的字段，`this.method`可以访问当前实例方法

```java
class Student {
    private String name;
    private int age;
    
    public String getName() {
        return this.name;
    }
    
    public int getAge() {
        return this.age;
    }
    
    public sayHello() {
        System.out.printf("Hello, My name is  %s, age is %d", this.getName(), this.getAge());
    }
}
```

### 冲突问题

如果没有命名冲突，可以省略`this`

```java
class Student {
    private String name;

    public String getName() {
        return name; // 相当于this.name
    }
}
```

如果局部变量和字段重名，那么局部变量优先级更高，就必须加上`this`

```java
class Student {
    private String name;

    public void setName(String name) {
        this.name = name; // 必须加 this
    }
}
```



## 方法重载

### 方法签名概念

方法签名是指：方法名 + 方法参数列表，**与返回值类型无关**

### 方法重载概念

可以为**同名方法**定义不同的实现，要求参数列表不同，即方法签名不同

### 方法重载意义

方法重载的意义是：功能类似的方法使用同一名字，更容易记住，调用起来更简单

### 示例代码

```java
class Hello {
    public void hello() {
        System.out.println("Hello, world!");
    }

    public void hello(String name) {
        System.out.println("Hello, " + name + "!");
    }

    public void hello(String name, int age) {
        if (age < 18) {
            System.out.println("Hi, " + name + "!");
        } else {
            System.out.println("Hello, " + name + "!");
        }
    }
}
```



## 构造方法

### 概念

构造方法用于创建对象

### 定义写法

构造方法是特殊的方法，表现在

* 无需写返回值类型（因为返回值肯定是对象类型，所以不需要也不能写）
* 方法名与类名同名

### 示例代码

```java
class Student {
    private String name;
    private int age;
    
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
```

### 默认构造方法

如果一个类没有定义构造方法，编译器会自动为我们生成一个默认构造方法，它没有参数，也没有执行语句，类似这样

```java
class Student {
    public Student() {}
}
```

如果自定义了构造方法，那么编译器就不会再自动生成默认构造方法了

```java
class Student {
    public Student(String name) {}	
}

public class Main {
    public static void main(String[] args) {
        Student p1 = new Student("alice"); // ok
        Student p2 = new Student(); // error, 编译出错：找不到该构造方法
    }
}
```

### 构造函数重载

如果既要能使用带参数的构造方法，又想保留不带参数的构造方法，那么只能把两个构造方法都定义出来（**构造函数重载**）

```java
class Student {
    public Student(String name) {}
    
    public Student() {} // 重载
}

public class Main {
    public static void main(String[] args) {
        Student p1 = new Student("alice"); // ok
        Student p2 = new Student(); // ok
    }
}
```

可以使用**this**在构造函数中调用其他构造函数

```java
class Student {
    public Student(String name) {} // 重载
    
    public Student() {
        this("默认名称")
    } 
}

public class Main {
    public static void main(String[] args) {
        Student p1 = new Student("alice"); // ok
        Student p2 = new Student(); // ok
    }
}
```

### 字段初始值问题

如果没有在构造方法中初始化字段，则字段都使用默认值

| 类型           | 默认初始值 |
| -------------- | ---------- |
| 引用类型       | null       |
| boolean        | false      |
| int            | 0          |
| float / double | 0          |
| char           | 0          |

```java
class Student {
    private String name; // 默认初始化为null
    private int age; // 默认初始化为0

    public Student() {}
}
```

可以进行**字段初始化**

```java
class Student {
    private String name = "alice";
    private int age = 18;

    public Student() {}
}
```

如果既对字段进行初始化，又在构造方法中对字段进行初始化，那顺序如何？

**顺序为：先字段初始化，再执行构造函数**

```java
class Student {
    private String name = "alice";
    private int age = 18;

    public Student(int age) {
        this.age = age;
    }
    
    public int getAge() {
        return this.age;
    }
}

public class Main {
    public static void main(String[] args) {
        Student st = new Student(20);
        System.out.println(st.getAge()); // 20
    } 
}
```



## 继承

### 继承介绍

| 项   | 说明                          |
| ---- | ----------------------------- |
| 作用 | 子类将继承父类的字段和方法    |
| 实现 | 使用 `extends` 关键字实现继承 |
| 术语 | 父类/超类/基类，子类/扩展类   |

### 示例代码

```java
class Person {
    private String name;
    private int age;

    public String getName() {}
    public void setName(String name) {}
    
    public int getAge() {}
    public void setAge(int age) {}
}

class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() { … }
    public void setScore(int score) { … }
}
```

### super关键字

`super`关键字表示父类，子类通过`super`引用父类，常用于获取父类构造方法

子类**不会继承**任何父类的构造方法：子类默认的构造方法是编译器自动生成的，不是继承的

```java
public class Main {
    public static void main(String[] args) {
        Student s = new Student("Xiao Ming", 12, 89);
    }
}

class Person {
    protected String name;
    protected int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

class Student extends Person {
    protected int score;

    public Student(String name, int age, int score) {
        this.score = score;
    }
}
```

### 上下转型

向上转型：父类引用指向子类对象，无需转换**（这是多态的核心）**

```java
Person p = new Person();
Student s = new Student();

Person ps = new Student(); // 父类引用指向子类对象，向上转型
```

向下转型：子类引用指向父类对象，需要强制转换

```java
Person p = new Person();
Student s = new Student();

Student sp = (Student) p; // 子类引用指向父类对象，向下转型，需要强制转换
```

### 单继承

Java中规定**只能有一个父类**，这称为**单继承**

### 阻止继承

在一个类定义前加上`final`修饰，该类就不能被继承

```java
// 加上 final，Person类不能被继承
final class Person {
    private String name;
    private int age;

    public String getName() {}
    public void setName(String name) {}
    
    public int getAge() {}
    public void setAge(int age) {}
}

// Error：Student不能继承Person，因为Person类被final修饰
class Student extends Person {
    // 不要重复name和age字段/方法,
    // 只需要定义新增score字段/方法:
    private int score;

    public int getScore() {}
    public void setScore(int score) {}
}
```

### 限制继承

> 版本要求：JDK >= 15

#### 概述

`Java 15`后允许使用`sealed`修饰类，并通过`permits`关键字明确写出能够从该类继承的子类名称

`sealed`类主要用于一些框架，防止继承被滥用

#### 示例代码

下面的`Shape`类就是一个`sealed`类，它只允许指定的3个类继承它

```java
public sealed class Shape permits Rect, Circle, Triangle {
}
```

```java
// ok，因为 Circle 在 permits 列表中
public final class Circle extends Shape {...} 

// error，Ellipse不在 permits 列表中 
// Compile error: class is not allowed to extend sealed class: Shape
public final class Ellipse extends Shape {...} 
```

### 组合和继承

#### 概述

继承是**is**关系，组合是**has**关系

#### 示例

假如有两个类，Book和Student

```java
class Book {
    protected String name;
}

class Student {
    protected int age;
}
```

如果描述 Student 有 Book，那么是否应该让 Student 继承 Book？

答案：不应该，Student 应该继承自 Person，而不是 Book，Student **has** Book，而不是 Student **is** Book

```java
class Student extends Person {
    protected Book book;
    protected int score;
}
```



## 封装

### 概述

`Java`是纯面向对象语言，它使用**权限修饰符**和**final**来实现**封装**的效果

### 权限修饰符

| 权限修饰符 | 说明                                     |
| ---------- | ---------------------------------------- |
| public     | 谁都可以访问                             |
| protected  | 作用于继承关系，只有类本身和子类能够访问 |
| private    | 只有类本身能访问                         |

#### 最佳实践

* 能不使用`public`，就不要使用`public`，尽量少暴露字段和方法
* 把方法定义为`package`权限有助于测试，因为测试类和被测试类只要位于同一个`package`，测试代码就可以访问被测试类的`package`权限方法
* 一个`.java`文件只能包含一个`public`类，但可以包含多个非`public`类；如果有`public`类，文件名必须和`public`类的名字相同

### final

| 修饰谁       | 说明                         |
| ------------ | ---------------------------- |
| 修饰局部变量 | 变为局部常量，阻止被重新赋值 |
| 修饰字段     | 变为常量字段，阻止被重新赋值 |
| 修饰方法     | 阻止被子类覆写               |
| 修饰类       | 阻止被继承                   |



## 多态

### 方法重写

#### 概述

在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为重写（Override）

可以添加注解**@Override**来让编译器检查是否是重写，**@Override**不是必需的

```java
// 父类
class Person {
    public void run() {
        System.out.println("Person.run");
    }
}

// 子类
class Student extends Person {
    @Override
    public void run() {
        System.out.println("Student.run");
    }
}
```

#### 重写与重载区别

* 重载：方法名相同，参数列表不同，返回值类型可以不同
* 重写：方法名、参数列表、返回值类型都要相同

```java
class Person {
    public void run() { … }
}

class Student extends Person {
    // 不是Override，因为参数不同:
    public void run(String s) {}
    // 不是Override，因为返回值不同:
    public int run() {}
}
```

#### 禁止重写

如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为`final`，被`final`修饰的方法不能被`Override`

```java
class Person {
    protected String name;
    public final String hello() {
        return "Hello, " + name;
    }
}

Student extends Person {
    // compile error: 不允许覆写
    @Override
    public String hello() {
    }
}
```

### 多态

| 项       | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| 多态概念 | 对于某个方法的调用，其真正执行的方法取决于运行时期实际类型的方法 |
| 多态本质 | 运行期动态决定调用的子类方法                                 |
| 多态核心 | 继承 + 方法重写 + 父类引用指向子类对象                       |

#### 示例代码

```java
public class Main {
    public static void main(String[] args) {
        Income[] incomes = new Income[] {
            new Income(3000),
            new Salary(7500),
            new StateCouncilSpecialAllowance(15000)
        };
        System.out.println(totalTax(incomes));
    }

    public static double totalTax(Income... incomes) {
        double total = 0;
        for (Income income: incomes) {
            total = total + income.getTax();
        }
        return total;
    }
}

class Income {
    protected double income;

    public Income(double income) {
        this.income = income;
    }

    public double getTax() {
        return income * 0.1; // 税率10%
    }
}

class Salary extends Income {
    public Salary(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        if (income <= 5000) {
            return 0;
        }
        return (income - 5000) * 0.2;
    }
}

class StateCouncilSpecialAllowance extends Income {
    public StateCouncilSpecialAllowance(double income) {
        super(income);
    }

    @Override
    public double getTax() {
        return 0;
    }
}
```



## 抽象类

### 概述

如果一个`class`定义了方法，但没有具体执行代码，目的是需要子类重写，那么这个方法就是抽象方法

因为`class`存在无法执行抽象方法，因此这个类也必须申明为抽象类

### 作用

抽象类与抽象方法的目的是为了**制定标准**，以及**配合多态**使用，称之为**面向抽象编程**

### 定义写法

使用 `abstract` 关键字去声明抽象类和抽象方法

```java
abstract class Person {
    public abstract void run();
}
```

### 特点

* 抽象类无法实例化，只能作为父类使用
* 具有抽象方法的类必须是抽象类
* 抽象类中的方法可以是普通方法，即非抽象方法



## 接口

### 概述

类似于**抽象类**，**接口**也是一种规范，区别在于接口的**抽象程度**更高

### 定义写法

使用 `interface` 关键字去声明接口

```java
interface Person {
    void run();
    String getName();
}
```

### 默认修饰符

因为 `interface` 的目的是**定义规范**，所以接口中声明的成员都是`public abstract`的，这两个修饰符是固定的，写不写都一样

```java
interface Person {
    void run();
    String getName();
}

// 等价于

interface Person {
    public abstract void run();
    public abstract String getName();
}
```

### 实现接口

实现接口使用 `implements` 关键字，实现时可以加上`@Override`注解来添加检查

```java
interface Person {
    void run();
    String getName();
}

class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        System.out.println(this.name + " run");
    }

    @Override
    public String getName() {
        return this.name;
    }
}
```

一个类可以实现多个接口

```java
class Animal implements Runable, Eatable { // 实现了两个interface
}
```

### 接口继承

一个接口可以继承别的接口（相当于扩展了接口的方法）

```java
interface SayHello {
    void hello();
}

interface Person extends SayHello {
    void run();
    String getName();
}
```

上述代码中，接口`Person`实际拥有三个抽象方法`hello`，`run`和`getName`

注意：一个**接口可以继承多个接口**，这与**类只能继承一个类**不同

```java
interface A {
    void a();
}

interface B {
    void b();
}

interface C extends A, B {
    void c();
}
```

### 接口字段

接口中可以定义接口字段，但有一定的限制

* 因为接口的本质是定义规范，所以接口字段一定是`public`的
* 因为是规范，所以接口字段一定是属于接口本身，且不能修改的，所以是`static final`的
* 所以接口字段的修饰符是：`public static final`的，这三个修饰符是固定的，写不写都一样

```java
interface Config {
    int port = 9876;
    String path = "/home/config";
}

// 等价于

interface Config {
    public static final
}
```

### 接口default方法

> 版本要求：JDK >= 8

#### 概述

在接口中，可以使用`default`关键字定义`default`方法，`default`方法可以有具体的实现

#### 作用

`default`方法的目的是：当需要给接口新增一个方法时，会涉及到修改全部子类，而如果新增的是`default`方法，那么子类就不必全部修改，只需要在需要重写的地方去重写新增方法

**避免牵一发而动全身**

#### 示例代码

```java
interface Person {
    String getName();
    default void run() {
        System.out.println(getName() + " run");
    }
}
```

`default`方法可以不实现

```java
class Student implements Person {
    private String name;

    public Student(String name) {
        this.name = name;
    }

    public String getName() {
        return this.name;
    }
    
    // 没有实现run方法
}
```

`default`方法可以直接使用

```java
public class Main {
    public static void main(String[] args) {
        Person p = new Student("Xiao Ming");
        p.run();
    }
}
```

### 抽象类与接口的对比

| 对比项     | 抽象类               | 接口                                                  |
| ---------- | -------------------- | ----------------------------------------------------- |
| 继承/实现  | 只能extends一个class | 可以extends多个interface，可以implements多个interface |
| 字段       | 可以定义实例字段     | 可以定义实例字段（有限制：public static final）       |
| 抽象方法   | 可以定义抽象方法     | 可以定义抽象方法                                      |
| 非抽象方法 | 可以定义非抽象方法   | 可以定义default方法                                   |



## 静态字段

### 概述

类中存在两种字段：实例字段和静态字段

### 区别

实例字段属于对象实例，实例字段由对象调用，实例字段在每个实例中都有自己的一个**独立空间**

静态字段属于类，静态字段由类调用，静态字段只有一个**共享空间**，所有实例都会共享该字段

### 写法

使用`static`修饰字段，即可将该字段定义为**静态字段**

```java
class Person {
    public static int age;
}
```

### 调用

正确的做法是通过类来调用，即**类名.静态字段**

```java
class Person {
    public static int age = 18;
}

public class Main {
    public static void main(String[] args) {
        System.out.println(Person.age);
    }
}
```

虽然可以通过实例对象来调用静态字段，但那是编译器做的自动转换，即编译器可以根据实例类型自动将**对象.静态字段**转换为**类名.静态字段**来访问，不推荐使用（语义不对）

通常情况下，通过实例变量访问静态字段，会得到一个编译警告

```java
class Person {
    public static int age = 18;
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();

        System.out.println(p.age); // 可以，但不推荐
    }
}
```



## 静态方法

### 概述

类中存在两种方法：实例方法和静态方法

### 区别

实例方法属于对象实例，实例方法由对象调用

静态方法属于类，静态方法由类调用

### 作用

静态方法经常用于工具类，例如：Arrays.sort()，Math.random()

### 写法

使用`static`修饰方法，即可将该方法定义为**静态方法**

```java
class Person {
    public static int age;

    public static void setAge(int value) {
        age = value;
    }
}
```

### 限制

由于静态方法属于类本身，所以无法访问实例属性，也无法使用`this`引用，只能访问静态属性

### 调用

正确的做法是通过类来调用，即**类名.静态方法**

```java
class Person {
    public static int age;

    public static void setAge(int value) {
        age = value;
    }
}

public class Main {
    public static void main(String[] args) {
        Person.setAge(99);
        System.out.println(Person.age);
    }
}
```

虽然可以通过实例对象来调用静态方法，但那是编译器做的自动转换，即编译器可以根据实例类型自动将**对象.静态方法**转换为**类名.静态方法**来访问，不推荐使用（语义不对）

通常情况下，通过实例变量访问静态方法，会得到一个编译警告

```java
class Person {
    public static int age;

    public static void setAge(int value) {
        number = value;
    }
}

public class Main {
    public static void main(String[] args) {
        Person p = new Person();
        
        p.setNumber(99); // 可以，但不推荐
        System.out.println(p.number); // 可以，但不推荐
    }
}
```



## 内部类

### 概述

定义在一个类内部的类，称为**内部类**

### 分类

Java中，内部类分为下列3种

| 内部类类型                        | 说明                                                         |
| --------------------------------- | ------------------------------------------------------------ |
| Inner Class（普通内部类）         | Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例 |
| Static Nested Class（静态内部类） | 类似于Inner Class，区别在于不依附外部类，而是一个完全独立的类 |
| Anonymous Class（匿名内部类）     | Anonymous Class用于不强调名称的类                            |



## 普通内部类（Inner Class）

### 定义

如果一个类定义在另一个类的内部，这个类就是`普通内部类（Inner Class）`

### 写法

在类的内部正常定义类就可以

```java
class 外部类 {
    class 内部类 {
        
    }
}
```

### 作用

`内部类`可以修改`外部类`的`private`字段，因为`内部类`的作用域在`外部类`之中，所以能访问`外部类`的`private`字段和方法

### 示例代码

```java
class Outer {
    private String name;

    Outer(String name) {
        this.name = name;
    }

    class Inner {
        void hello() {
            System.out.println("Hello, " + Outer.this.name);
        }
    }
}
```

### 实例化

要实例化一个`Inner`，必须首先创建一个`Outer`的实例，然后调用`Outer`实例的`new`来创建`Inner`实例

```java
public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("Nested"); // 实例化一个Outer
        Outer.Inner inner = outer.new Inner(); // 实例化一个Inner
        inner.hello();
    }
}
```

### 访问Outer实例

可以用`Outer.this`访问Outer实例

### 特殊点总结

| 特殊点      | 说明                   |
| ----------- | ---------------------- |
| Outer.Inner | 普通内部类的类型       |
| Outer.this  | 指向外部类实例对象     |
| Outer.new   | 用于创建普通内部类对象 |



## 静态内部类（Static Nested Class）

### 定义

静态内部类和普通内部类相似，但是使用`static`修饰，称为静态内部类

### 区别

静态内部类不再依附于`外部类`的实例，而是一个完全独立的类

因此静态内部类无法引用`外部类.this`，但它可以访问`外部类`的`private`静态字段和静态方法

### 示例代码

```java
class Outer {
    private static String NAME = "OUTER";

    private String name;

    Outer(String name) {
        this.name = name;
    }

    static class StaticNested {
        void hello() {
            System.out.println("Hello, " + Outer.NAME);
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Outer.StaticNested sn = new Outer.StaticNested();
        sn.hello();
    }
}
```



## 匿名内部类（Anonymous Class）

### 定义

匿名内部类不是定义在类的内部，而是定义在方法的内部

### 写法

在定义匿名类的时候就必须实例化它

```java
// 声明并实例化
父类类型 变量名 = new 父类类型() {
    // 实现必要的抽象方法...
}
```

### 作用

定义匿名类的作用是在不关心类名的场合，比直接定义**普通内部类**可以少写很多代码

### 示例代码

`Runnable`本身是接口，接口是不能实例化的，这里本质上是定义了一个实现了`Runnable`接口的匿名类，并且通过`new`实例化该匿名类，然后转型为`Runnable`

```java
class Outer {
    private String name;

    Outer(String name) {
        this.name = name;
    }

    void asyncHello() {
        Runnable r = new Runnable() {
            @Override
            public void run() {
                System.out.println("Hello, " + Outer.this.name);
            }
        };
        new Thread(r).start();
    }
}

public class Main {
    public static void main(String[] args) {
        Outer outer = new Outer("Nested");
        outer.asyncHello();
    }
}
```

### 编译结果

`Outer`被编译为`Outer.class`，而匿名类被编译为`Outer$1.class`

如果有多个匿名类，Java编译器会将每个匿名类依次命名为`Outer$1`、`Outer$2`、`Outer$3`



## 总结

### 修饰符总结

| 修饰符    | 总结                          |
| --------- | ----------------------------- |
| public    | 公开权限                      |
| protected | 保护权限                      |
| private   | 私有权限                      |
| abstract  | 抽象                          |
| static    | 静态                          |
| final     | 限制不变                      |
| default   | 用于接口中，定义`default`方法 |

书写顺序如下

```java
[public/protected/private] [abstract] [static] [final]
```

### final总结

| final修饰谁       | 说明                         |
| ----------------- | ---------------------------- |
| final修饰局部变量 | 变为局部常量，阻止被重新赋值 |
| final修饰字段     | 变为常量字段，阻止被重新赋值 |
| final修饰方法     | 阻止被子类重写               |
| final修饰类       | 阻止被继承                   |
