## 什么是方法

方法类似于函数，都是对一些代码功能的封装

方法与函数区别

* 方法需要绑定到数据类型上，使该数据类型的实例都可以使用这个方法
* 方法不能独自调用，只能通过绑定的数据类型的实例进行调用



## 方法的定义与使用

```go
type A struct {
  Name string
}

func (a A) test() {
  fmt.Println(a.Name)
}

func main() {
  a := A{Name:"golang"}
  a.test()
}
```



## 方法注意事项

* 任何的自定义类型都可以添加相应的方法，不仅仅是结构体

* 接收者必须有一个显式的名字，命名规范是接收类型的名称（首字母要改为小写），且这个名字必须在方法中被使用，

* 如果方法不需要使用接收者，可以用 `_` 表示

  ```go
  func (_ ReceiverType) methodName(parameterList) (returnValueList) { ... }
  ```

* 类型和作用在它上面定义的方法必须在同一个包里定义

  这就是为什么不能在 `int`、`float` 或类似这些的类型上定义方法

  可以使用自定义类型来解决

* Go中的 `toString` 方法

  ```go
  func (a type) String() string { ... }
  ```



## 值接收者和指针接收者对比

| 接收者类型 | 定义                       | 本质                                               | 语法糖                                                       |
| ---------- | -------------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 值接收者   | 值接收者的类型为值类型     | 本质是进行拷贝，传入的是拷贝值，操作不会影响调用者 | 调用者为对应值类型：直接调用<br />调用者为对应类型的指针类型：编译器底层自动解指针后再调用 |
| 指针接收者 | 指针接收者的类型是指针类型 | 本质是进行传递，传入的是地址值，操作会影响调用者   | 调用者为对应值类型：编译器底层自动取地址后再调用<br />调用者为对应值类型的指针类型：直接调用 |

> 无论调用者是值类型还是指针类型，实际调用类型还是方法定义的接收者类型

### 接收者类型选择

当符合以下情况时，选择指针接收者

* 需要修改接收者的内容
* 接收者是拷贝代价比较大的对象
* 保证一致性，如果某个方法使用了指针接收者，那么其他的地方也应该使用指针接收者