## 概述

### 定义

`Go`中一个包对应一个文件夹，文件夹中的文件名可以随意起名，但是每个文件的第一行必须要求是 `package 包名`，而且必须是同一个，即**一个文件夹中的源码不能出现多个package**

`Go` 中每一个文件都属于一个包，`包名`和`文件夹名`不要求一致，目录名，文件名，包名三者不需要相同

### 作用

声明某个`go`文件是某个包，区分相同名字的文件或标识符

对函数以及变量进行管理，控制函数，变量的作用域

### 命名规范

包的名字规范是全小写且不用 `_` 进行分隔，比如

```go
package httpserver
package databasemodel
```



## 包的种类

1. Go语言自带的标准包
2. 自己写的包
3. 第三方包



## 包的声明

在`go`源文件第一行进行定义

```go
package 包名 // 源文件第一行
```



## 包的导入

### import语句

`import`后面跟的不是`包名`，而是`包的路径`

```go
// 单个导入
import "fmt"
import "strconv"

// 批量导入
import (
  "fmt"
  "net/http"
  "os/ioutil"
)
```

### 搜索路径

传统包依赖管理：`标准库($GOROOT/src)` ==> `$GOPATH/src`

### 别名机制

导入包时，可以给包起别名，从而避免冲突

* 如果别名是 `_` 则说明只执行该包的`init`函数，而不导入该包内容
* 如果别名是 `.` 则说明将要导入的包的导出内容混入到当前文件中

```go
// 如果包太长，可以给包改名，也可以避免重名的问题
import util "os/ioutil"

// 匿名导入：导入却不使用（目的是为了执行 init 函数）
import _ "mysql"

// 将 fmt 包中的导出内容混入到当前文件中
import . "fmt"

func main() {
  Println("fmt包的导出内容混入到当前文件中了")
}
```

### 导入路径

导入包可以写绝对路径和相对路径

* 绝对路径：从 `$GOPATH/src` 目录起，写绝对路径
* 相对路径：以当前文件为基准点

```go
import (
  "myProject/db" // 绝对路径导入
  "../mylog"     // 相对路径导入
)
```



## 包的init函数

1. 一个包一旦被导入，就会自动执行这个包中的 `init` 函数，`init`函数只能由`Go`来调用，程序员无法主动调用

2. 一个包中可以有多个 `init` 函数，但最好只有一个

3. 包的`init`函数只会执行一次，哪怕它被多处导入，也只会执行一次
4. 包可以重复引用，且只会实际执行init函数一次

![](./images/image-20200308140714300.png)

![](./images/image-20200308141026090.png)



## 包的注意事项

1. 不能将多个包放在同一目录下，也不能将一个包拆分到多个目录下，总结：一个包唯一对应一个目录

2. 目录名，文件名，包名三者不需要相同，三者名称不同也符合规定

3. 如果导入了包而不使用则会编译错误，如果只想执行包中的 `init` 函数而不想使用，则可以用 `_`

   ```go
   import _ "mysql"
   ```

4. 如果想要定义一个 `Go` 文件是可执行文件，则需要将这个文件所属包声明为 `main`

   `main`包中不同的文件的代码不能互相调用，即`main `包最好只有一个文件

5. 导入的是路径，使用的是包名

6. 包不能出现循环引用问题



## 导出与未导出

### 导出与未导出的含义

如果一个标识符（类型，方法，函数等）是导出的，则在其他包中可以使用该标识符

如果一个标识符（类型，方法，函数等）是未导出的，则在其他包中不可以使用该标识符

### 使用首字母大写决定是否导出

如果一个标识符（类型，方法，函数等）名字的首字母是大写字母，则它是导出的，否则它是未导出的

### 使用未导出标识符的方法

使用未导出标识符的方法是：

* 定义一个导出的方法，在里面使用该未导出的标识符，然后通过使用这个导出的方法来间接使用该未导出的标识符

* 短变量声明操作符，有能力捕获引用的类型，并创建一个未公开的类型的变量，永远不能显式创建一个未公开的类型的变量，但短声明操作符能够这么做



## GOPRIVATE环境变量

### 概述

当设置完 GOPROXY 后，GO会从代理地址（如 https://goproxy.cn）中拉取包，并且会对下载的软件包和代码库进行完整性校验

当如果仓库是私有仓库那就不应该走 proxy 了，这时候就可以通过设置 GOPRIVATE 变量来跳过代理下载和禁用代码完整性校验

### 使用

GOPRIVATE：支持用逗号分隔，可以填写多个值

```shel
go env GOPRIVATE=*.corp.example.com,*.private.com
```

### 本质

设置 `GOPRIVATE` 本质上设置了 `GONOPROXY` 和 `GONOSUMDB`，即

```shell
go env GOPRIVATE=*.corp.example.com
```

等价于

```shell
go env GONOPROXY=*.corp.example.com
go env GONOSUMDB=*.corp.example.com
```

可以灵活调整上述两个环境变量，如

```shell
GOPRIVATE=*.corp.example.com
GOPROXY=proxy.example.com
GONOPROXY=none
```

这样 `Go` 和其他工具就会把 `corp.example.com` 这个域名下的依赖包识别成私有的，但是用户仍然会从公司内部的代理镜像服务器 `proxy.example.com` 上下载所有公有和私有的仓库，因为用户设置了 `GONOPROXY=none`， 这个设置会覆盖 `GOPRIVATE` 变量

