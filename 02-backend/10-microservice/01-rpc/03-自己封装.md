## handler

```go
package handler

// 解决名称冲突问题
const HelloServiceName = "handler/HelloSerivce"

type NewHelloService struct {}

func (s *NewHelloService) Hello(request string, reply *string) error {
    *reply = "hello, " + request
    return nil
}
```



## ServerProxy

```go
package server_proxy

import "handler"

type HelloServicer interface {
    Hello(request string, reply *string) error
}

func RegisterHelloService(srv HelloServicer) error {
    return rpc.RegisterName(handdler.HelloServiceName, srv)
}
```



## Server

```go
import "handler"

func main() {
    listener, _ := net.Listen("tcp", ":1234")
    _ = server_proxy.RegisterName(&handler.HelloService{})
    
    for {
        conn, _ := listener.Accept()
	    go rpc.ServeConn(conn)
    }
}
```



## ClientProxy

```go
package client_proxy

type HelloServiceStub struct {
    *rpc.Client
}

func NewHelloServiceClient(protocol, address string) HelloServiceStub {
    conn, err := rpc.Dial(protocol, address)
    if err != nil {
        panic("connect error")
    }
    return HelloSeriveStub{conn}
}

func (c *HelloServiceStub) Hello (request string, reply *string) error {
    err := c.Call(handler.HelloServiceName+".Hello", request, reply)
    
    if err != nil {
        return err
    }
    
    return nil
}
```



## Client

```go
func main() {
    client := client_proxy.NewHelloServiceClient("tcp", "localhost:1234")
    
    var reply string
    
    // 这就像本地调用一样！！！！
    err := client.Hello("alice", &reply)
    if err != nil {
        panic(err)
    }
    fmt.Println(reply)
}
```



## 问题

1. 这些概念proxy、handler都在grpc中有对应
2. 这些proxy能否自动生成（为多种语言生成）
3. 都能满足，这就是grpc (protobuf)