## 缓存概述

### 缓存定义

浏览器在本地磁盘上将用户之前请求到的数据存储起来，当用户再次访问数据时，无需再次通过网络向服务器获取，而是可以直接在本地网页进行获取

### 缓存的好处

1. 减少请求的个数
2. 节省带宽，避免浪费不必要的网络资源
3. 减轻服务器压力
4. 提高浏览器网页的加载速度，提高用户体验



## 缓存分类

### 强缓存

不会向服务器发送请求，直接从本地缓存中获取数据

请求资源的响应状态码为：`200 ok(from memory cache)`

直到资源过期，才会再次向服务器发送请求获取资源

### 协商缓存

会向服务器发送请求，服务器会根据请求头的资源判断是否命中协商缓存

如果命中，则响应状态码为`304 Not Modified`，告知浏览器从缓存中读取资源

### 两者异同

相同点：都是从浏览器中读取资源

不同点：强缓存不会发送请求给服务器，协商缓存会发送请求到服务器，根据服务器返回的信息决定是否使用缓存



## 协商缓存相关参数

### 核心重点

协商缓存都是由服务器来决定缓存资源是否可用，所以客户端与服务器需要通过某些标识来通信，从而让服务器判断请求资源是否可以读取缓存

### 第一组参数：last-modified 和 if-modified-since

last-modified 和 if-modified-since 的值是 GMT 格式的时间字符串

#### 参数1：last-modified

浏览器第一次向服务器请求资源，服务器在返回这个资源的同时，会在response的header中加上 last-modified 这个字段，用来标识该资源在服务器上最后的修改时间，浏览器会记录下这个资源的最后修改时间

#### 参数2：if-modified-since

浏览器再次跟服务器请求这个资源时，会在request的header上加上 if-modified-since 这个字段，用来标识浏览器中缓存的资源的最后修改时间

服务器再次收到资源请求时，会根据浏览器传过来的 if-modified-since 的值和资源在服务器上的最后修改时间进行对比，判断出浏览器上缓存的资源是否可用

* 如果资源没有变化（即命中协商缓存）

  则返回 `304 Not Modified`，response header中不会再次添加 last-modified 这个header（因为资源没有改变，则 last-modified 值不会改变）

  浏览器受到`304`响应后，则直接从浏览器中加载资源

* 如果资源发生改变（即没有命中协商缓存）

  浏览器会从服务器获取新的数据，同时刷新该资源的 last-modified 和 if-modified-since

### 第二组参数：etag 和 if-none-match

这两个值是由服务器为每一个生成的唯一的标识字符串，只要资源发生变化，这个值就会改变

etag是服务器的reponse的header，if-none-match 是客户端的request的header

#### 参数1：etag

浏览器第一次向服务器请求资源，服务器在返回这个资源的同时，会在response的header中加上 etag 这个字段，用来唯一标识该资源

#### 参数2：if-none-match

浏览器再次跟服务器请求这个资源时，会在request的header中加上 if-none-match 这个字段，用来表示缓存资源的唯一标识

服务器再次受到资源请求时，会根据浏览器传过来的 if-none-match 的值和服务器上的资源进行对比，判断出浏览器上缓存的资源是否可用

* 如果资源没有变化（即命中协商缓存）

  则返回 `304 Not Modified`，response header中不会再次添加 etag 这个header（因为资源没有改变，则 etag 值不会改变）

  浏览器受到`304`响应后，则直接从浏览器中加载资源

* 如果资源发生改变（即没有命中协商缓存）

  浏览器会从服务器获取新的数据，同时刷新该资源的 etag 和 if-none-match

### etag 和 last-modified 的取舍

last-modified/if-modified-since 是 HTTP 1.0 中的规定的，而 etag/if-none-match 是 HTTP 1.1 中新增的

etag/if-none-match的出现是为了应对下列的场景的优化

* 一些文件也许会周期性更改，但是它的内容并不会发生改变（改变的仅仅是修改时间），这个时候并不希望客户端去重新获取数据
* 某些文件的修改是非常频繁的（比如秒级以下修改很多次），if-modified-since能检查到的颗粒度是秒，所以无法应对这种情况下的修改
* 某些服务器并不能精确到文件的最后修改时间

总结：利用 etag/if-none-match 能够更加精确地控制缓存，因为 etag 是服务器根据文件实际内容生成的唯一标识，而不是利用修改时间来进行判断